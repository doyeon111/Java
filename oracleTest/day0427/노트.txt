* rownum
	- 오라클에서 내부적으로 생성되는 가상 컬럼으로 sql 조회 결과의 순번을 나타냄.
	- select 결과에 행번호를 매겨주는 속성
	
	
	연습) '대한민국'에 거주하는 고객의 이름과 주소를 출력
		select name, address 
		from customer
		where address like '대한민국%'; 
		
		
	연습) '대한민국'에 거주하는 고객의 이름과 주소를 출력합니다.
		출력결과에 행 번호를 붙입니다.
		select rownum, name, address 
		from customer
		where address like '대한민국%';
		
		select rownum no, name, address //rownum에 no라는 애칭을 주어 출력
		from customer
		where address like '대한민국%';
		
		
	연습) '대한민국'에 거주하는 고객의 이름과 주소를 행번호를 붙여 앞에서 2명만 출력
		select rownum no, name, address
		from customer
		where address like '대한민국%' and rownum <= 2;
		
		
	**연습) '개발팀'에 근무하는 남자직원들의 사원번호, 이름, 관리자명, 연봉, 입사일, 아이디, 주민번호를 출력합니다.
		출력결과에 순번을 매겨 출력하고 연봉은 반올림하여 10의자리까지 출력하며 10칸을 잡아 오른쪽 정렬하여 빈칸은 0으로 채운다. 
		아이디는 10칸을 잡아 왼쪽정렬하여 출력하고 빈칸은 *로 채운다.
		주민번호는 앞에서 8글자만 14칸을 잡아 왼쪽정렬하여 출력하고 빈칸은 *로 채운다.
		
		select rownum, e.eno, e.ename, m.ename, 
		lpad(round((e.salary+e.comm) * 12, 1), 10, 0) salary, 
		e.hiredate, rpad(substr(e.email, 1, instr(e.email, '@')-1), 10, '*') id,
		rpad(substr(e.jumin, 1, 8), 14, '*') jumin
		from emp e, emp m, dept d
		where e.mgr = m.eno and d.dno = e.dno and 
		dname = '개발%' and substr(e.jumin, 8, 1) in ('1', '3');
		
		
		select rownum, e.eno, e.ename, m.ename, 
		lpad(round((e.salary+e.comm)*12,1),10,0) salary,
		e.hiredate, 
		rpad( substr(e.email, 1, instr(e.email, '@') - 1 ), 10, '*') id,
		rpad( substr(e.jumin,1, 8 )  , 14, '*') jumin
		from emp e, emp m, dept d where
		e.mgr = m.eno and
		e.dno = d.dno and 
		dname like '개발%' and 
		substr(e.jumin, 8, 1) in ('1', '3');
		
		
		
	연습) 모든 고객의 고객번호와, 이름을 출력합니다.
		select rownum, custid, name from customer;
		
		
	연습) 고객번호를 기준으로 내림차순하여 고객번호와 이름을 출력
		select custid, name from customer order by custid desc;
	
	
	연습) 고객번호로 내림차순으로 정렬하여 고객번호와 이름을 순번을 붙여 출력
		select rownum, custid, name 
		from customer 
		order by custid desc;
	
		==> select절을 먼저 실행하고 order by 를 실행한다.
		==> 우리가 원하는 것은 order by를 먼저하고 select를 동작하도록 !
		
		실행결과는 rownum과 custid가 둘 다 desc로 나옴.
		
		order by와 행번호를 같이 쓸 때에는 
		order by 실행결과를 먼저 동작하도록 하기 위하여 서브쿼리를 사용해야 한다.
		
		
		//order by 한 쿼리문을 from절 안에 넣어주면 order by가 먼저 실행하게 된다.
		select rownum, custid, name 
		from (select custid, name 
				from customer 
				order by custid desc);

	
	
	연습) 가장 비싼 도서 3권의 정보를 출력합니다. 
		
		<행번호를 붙인 것>
		select rownum, bookid, bookname, publisher, price
		from(select * from book order by price desc)
		where rownum <= 3;
		
		    ROWNUM BOOKID BOOKNAME          PUBLISHER          PRICE
		---------- ------ ----------------- --------------- --------
		         1     13 스포츠 세계          대한출판사          50,000
		         2      7 야구의 추억          이상미디어          40,000
		         3     14 재미있는 자바         쌍용미디어          35,000
		         
		 ==> 행번호를 출력하려면 컬럼 이름들을 나열해야 한다.
		--------------------------------------------------------------------
		
		<행번호를 안 붙이고 싶을 때>
		select bookid, bookname, publisher, price
		from(select * from book order by price desc)
		where rownum <= 3;
	
		BOOKID BOOKNAME          PUBLISHER          PRICE
		------ ----------------- --------------- --------
		    13 스포츠 세계          대한출판사           50,000
		     7 야구의 추억          이상미디어           40,000
		    14 재미있는 자바         쌍용미디어           35,000
	
	
		--------------------------------------------------------------------
		<위 쿼리와 동일>
		select *
		from(select * from book order by price desc)
		where rownum <= 3;
		=> 행번호를 출력할 필요가 없다면 와일드 문자(*)로 표현할 수 있다.
	
-------------------------------------------------------------------------------------------------

실습을 위한 테이블 만들기

	create table mybook(
		bookid number primary key,
		price number
	);


	insert into mybook values(1, 10000);
	insert into mybook values(2, 20000);
	insert into mybook values(3, null);

	1) select * from mybook;
	
		BOOKID    PRICE
		------ --------
		     1   10,000
		     2   20,000
		     3
	
	
	
	2) select bookid, nvl(price, 0) from mybook;
		==> price가 null이면 0으로 출력 null이 아닌 것은 원래의 값을 출력
	
		BOOKID NVL(PRICE,0)
		------ ------------
		     1        10000
		     2        20000
		     3            0
	
	
	
	
	3) select * from mybook where price is null; //null인 가격의 정보를 출력
	
		BOOKID    PRICE
		------ --------
		     3
		     
		     
	
	4) select * from mybook where price='';
		==> price는 숫자 자료형이고, ''(홋따옴표)로 묶는 표현은 문자이다. null인 것을 찾기 위해서는 is null으로 표현한다.
	
		선택된 레코드가 없습니다.
		
		
		
	
	5) select bookid, price + 100 from mybook;
		==> null인 항목에는 연산이 되지 않는다.
	
		BOOKID  PRICE+100
		------ ----------
		     1      10100
		     2      20100
		     3
		     
		==> 만약, null인 항목도 연산을 시키려면 nvl함수를 이용하여 다른 값으로 대체한 후에 연산을 시킬 수 있다.
		select bookid, nvl(price, 0) + 100 from mybook;
		
		BOOKID NVL(PRICE,0)+100
		------ ----------------
		     1            10100
		     2            20100
		     3              100
				
		
		
	
	6) select sum(price), avg(price), count(*) from mybook where bookid >= 4; //bookid의 값이 4보다 큰 값은 없기 때문에 null로 나옴.
	
		SUM(PRICE) AVG(PRICE)   COUNT(*)
		---------- ---------- ----------
		                               0
		                               
		==> 조건을 만족하는 레코드가 없을 때에 count는 0을 반환하고 나머지 집계함수들은 null을 반환                               
	
	
	
	7) select count(*), count(price) from mybook;
	
		  COUNT(*) COUNT(PRICE)
		---------- ------------
		         3            2
	
		==> count(*) : 모든 레코드의 수
			count(price): price의 컬럼의 값이 null이 아닌 레코드의 수
	
	
	
	
	8) select sum(price), avg(price) from mybook;

		SUM(PRICE) AVG(PRICE)
		---------- ----------
		     30000      15000

		==> sum(price) : null을 제외한 price의 합계
			avg(price) : null을 제외한 price의 평균


		select avg(nvl(price, 0)) from mybook;  ==> 10000

	9) 컬럼포멧이 맞지 않을 때 ###으로 나옴.
		BOOKID    PRICE
		------ --------
		     1		###
			 2	    ###


-----------------------------------------------------------------------------------------

* rownum에 관한 문제풀이

	1) select * from book;
	
	2) select * from book where rownum <= 5;
		
		BOOKID BOOKNAME          PUBLISHER          PRICE
		------ ----------------- --------------- --------
		    14 재미있는 자바         쌍용미디어        35,000
		    13 스포츠 세계          대한출판사        50,000
		     1 축구의 역사          굿스포츠           7,000
		     2 축구아는 여자         나무수            13,000
		     3 축구의 이해          대한출판사        22,000
	
	
	
	3) select * from book where rownum <= 5 order by price;
	
		BOOKID BOOKNAME          PUBLISHER          PRICE
		------ ----------------- --------------- --------
		     1 축구의 역사          굿스포츠            7,000
		     2 축구아는 여자         나무수            13,000
		     3 축구의 이해          대한출판사          22,000
		    14 재미있는 자바         쌍용미디어          35,000
		    13 스포츠 세계          대한출판사          50,000
	
	==> 행번호를 붙여 5개를 뽑은 다음 가격순으로 정렬
	==> 가격순으로 정렬하여 5개 뽑은 것 하고는 달라요 !
	
	4) select * from (select * from book order by price) b where rownum <= 5;
		
		BOOKID BOOKNAME          PUBLISHER          PRICE
		------ ----------------- --------------- --------
		     6 역도 단계별 기술       굿스포츠           6,000
		     1 축구의 역사           굿스포츠           7,000
		     9 올림픽 이야기         삼성당             7,500
		     5 피겨 교본            굿스포츠           8,000
		     2 축구아는 여자         나무수            13,000
		
		==> 정렬하는 쿼리를 from절 안에 넣어줘야 함!
		
		
		
	5) select * from (select * from book where rownum <=5) b order by price;
	
		BOOKID BOOKNAME          PUBLISHER          PRICE
		------ ----------------- --------------- --------
		     1 축구의 역사          굿스포츠           7,000
		     2 축구아는 여자         나무수            13,000
		     3 축구의 이해          대한출판사        22,000
		    14 재미있는 자바        쌍용미디어        35,000
		    13 스포츠 세계         대한출판사        50,000
		    
		==> 행번호르 5번까지 뽑은 다음 가격순으로 정렬    
		    
	
	6) select * from (select * from book where rownum <=5 order by price) b;
	
		BOOKID BOOKNAME          PUBLISHER          PRICE
		------ ----------------- --------------- --------
		     1 축구의 역사          굿스포츠           7,000
		     2 축구아는 여자         나무수            13,000
		     3 축구의 이해          대한출판사        22,000
		    14 재미있는 자바        쌍용미디어        35,000
		    13 스포츠 세계          대한출판사        50,000


--------------------------------------------------------------------------------------------------------------

* 부속질의(subquery)
	- 하나의 sql문 안에 포함되는 또 다른 sql문이 중첩된 질의를 말한다.
	- 다른 테이블에서 가져온 데이터로 현재 테이블에 있는 정보를 찾거나 가공할 때 사용한다.
	- 보통 데이터가 대량일 때 데이터를 모두 합쳐서 연산하는 조인보다 필요한 데이터만 찾아서 공급해주는 부속질의가 성능이 더 좋다.
	- 주질의(main query, 외부질의)와 부속질의(sub query, 내부질의)로 구성됨.



	* 서브쿼리의 위치
		
		* select 절 (스칼라 서브쿼리)
			- select 절에 컬럼이름이 오는 곳에 사용되는 서브쿼리를 말한다.
			- 단일행이 오도록 표현해야 한다.
			
				연습) 고객별 고객아이디, 이름, 총 주문금액을 출력
				
					select custid, sum(saleprice) 
					from orders 
					group by custid;
					
					==> 주문에 대한 내역은 orders에 있고 고객이름은 customer에 있다.
						만약, 위의 결과에 고객 이름도 같이 출력하려면 조인을 해야 한다.
						join을 하지 않고 스칼라 서브쿼리를 이용하여 고객이름을 같이 출력할 수 있다.
						
						select custid, (select name 
											from customer c
											 where o.custid = c.custid) name, sum(saleprice) saleprice
						from orders o
						group by custid;
			
						CUSTID NAME     SALEPRICE
						------ -------- ---------
						     2 김연아      27,000
						     5 박세리      22,000
						     1 박지성      53,000
						     3 장미란      31,000
						     4 추신수      33,000
			
				
				연습) 고객이름 별로 판매액을 출력
					
					select (select name 
								from customer c 
								where c.custid = o.custid) name, sum(saleprice) total
					from orders o
					group by custid;
					
					
			==> 서브쿼리에 조건식이 메인쿼리와 조건식이 있어서 join이라고 생각할 수 있는데 이 경우 조인이라고 하지않고 '상관 서브쿼리'라고 한다.
			
			
				연습) 스칼라 서브쿼리를 이용하여 도서명별 판매건수를 출력
					
					select (select bookname
								from book b
								where b.bookid = o.bookid) bookname, count(saleprice) 
					from orders o
					group by bookid;
			
			
			
			
				연습) 스칼라 서브쿼리를 이용하여 부서명별로 근무자의 수, 평균급여, 최고급여를 출력
				
					select (select dname
								from dept d
								where d.dno = e.dno) dname, count(*), avg(salary), max(salary)
					from emp e
					group by dno;
					
					
					
			<실습을 위하여 orders 테이블에 bookname 칼럼을 추가>
			alter table orders add bookname varchar2(20);
					
					
					
				<<update 문에 사용된 스칼라 서브쿼리>>
				update 테이블명 set 컬럼명 = (서브쿼리);
				
					연습) orders 테이블에 각 주문에 대하여 주문에 맞는 도서 이름을 수정
						
						update orders o set bookname = (select bookname 
														from book b
														where b.bookid = o.bookid);
					
		
		* from 절 (인라인 뷰)
			- 서브쿼리가 from 절에서 사용되는 부속질의
			- 실제로 존재하지 않는 select 한 결과를 가상의 테이블(View)라고 한다.
			
				연습) 고객번호가 2 이하인 고객들에 대하여 고객 이름별로 총 판매액을 출력
				
					- 고객번호가 2 이하인 고객들
					select custid, name
					from customer 
					where custid <= 2;
					=> 이 결과를 from절에 표현하여 가상의 테이블로 하여 orders와 조인하여 결과를 출력
					
					select name, sum(saleprice)
					from (select custid, name
							from customer 
							where custid <= 2) c, orders o
					where c.custid = o.custid
					group by name;
				
				----------------------------------------------------------------
				
				select 컬럼1, 컬럼2
				from 테이블1, 테이블2
				where 조건식
				==> 테이블1, 테이블2 자리에 서브쿼리를 표현할 시점에는 바깥에 메인쿼리가 누군지 모르기 때문에 상관서브쿼리로 표현할 수 없다.
			
			
			
		* where 절 (중첩쿼리)

			*** 다중행 연산자에 대하여 설명하세요.
			===> 서브쿼리가 where절에 사용될 때에 서브쿼리의 건수가 여러 건일 때 사용하는 연산자이면
				 in, not in, all, some, any 등이 있습니다.
			
			
				연습) 평균 주문금액 이하의 주문에 대한 주문번호와 금액을 출력
					
					select orderid, saleprice
					from orders
					where saleprice <= (select avg(saleprice) from orders);
		


				연습) 각 고객의 평균 주문금액 이하의 주문에 대한 주문번호와 고객번호, 주문 금액을 출력
					
					select orderid, custid, saleprice
					from orders o1
					where saleprice <= (select avg(saleprice)
											from orders o2
											where o1.custid = o2.custid);


				연습) '대한민국'에 거주하는 고객에게 판매한 도서의 총 판매금액을 출력
					
					select sum(saleprice)
					from orders
					where custid = (select custid 
										from customer
										where name = '박지성');
					===> 이 때 서브쿼리의 건수는 1건이기 때문에 = 연산자를 사용할 수 있다.


					select sum(saleprice)
					from orders
					where custid in (select custid 
										from customer
										where address like '%대한민국%');

					==> 서브쿼리의 건수가 여러 건이기 때문에 = 연산자는 사용할 수 없고, in 연산자를 사용해야 한다.


					
					<<다중행 연산자>>
						- 서브쿼리가 where절에 사용이 될 때에 서브쿼리의 건수가 여러 건일 때 사용하는 연산자들
						
						* in
							- 서브쿼리의 건수가 여러 건일 때 = 을 대신하여 사용
							
							select sum(saleprice)
							from orders
							where custid in (select custid 
												from customer
												where address like '%대한민국%');

							==> 서브쿼리의 건수가 여러 건이기 때문에 = 연산자는 사용할 수 없고, in 연산자를 사용해야 한다.
						
						
						
						* all, any(some)
							- 서브쿼리의 건수가 여러 건일 때 비교연산자 > < >= <= 을 표현할 때 같이 사용
							
						
								연습) 3번 고객이 주문한 도서의 최고 금액보다 더 비싼 도서를 구입한 주문의 주문번호와 주문금액을 출력
								
									select orderid, saleprice
									from orders
									where saleprice > (select saleprice from orders where custid = 3);
									
									ORA-01427: 단일 행 하위 질의에 2개 이상의 행이 리턴되었습니다.

									==> 오류 , 서브쿼리이 건수가 여러 건이기 때문에 단일행 연산자인 > 를 사용할 수 없고,
										다중행 연산자인 all, some(any)와 같이 사용해야 한다.
										
									지금은 3번 고객이 주문한 최고금액보다 비싼 주문을 검색해야하기 때문에 서브쿼리의 결과보다 모두 커야 한다.
									그래서 all과 같이 사용한다.
									
									select orderid, saleprice
									from orders
									where saleprice > all (select saleprice from orders where custid = 3);


									위에 표현된 > all (서브쿼리) 를 max함수를 사용하여 단일행 연산자로도 표현할 수 있다 !
									
									select orderid, saleprice
									from orders
									where saleprice > (select max(saleprice) from orders where custid = 3);

						
						
						* exists: 서브쿼리의 건수가 있으면 메인쿼리를 동작
						  not exists: 서브쿼리의 건수가 없으면 메인쿼리를 동작
						  
						  		연습) exists 연산자를 이용하여 대한민국에 거주하는 고객에게 판매한 도서의 총 판매액을 출력
						  		
						  			select sum(saleprice)
						  			from orders o
						  			where exists (select * from customer c
						  							where address like '%대한민국%' and c.custid = o.custid);
	
	
				연습) 
					1) select custid, (select address 
										from customer cs
										where cs.custid = od.custid) address, sum(saleprice) total
						from orders od
						group by od.custid;
						
						==> select 절 (스칼라 서브쿼리)
						==> 고객아이디, 주소, 총주문금액을 출력
						
						
					2) select cs.name, s
						from(select custid, avg(saleprice) s
								from orders
								group by custid) od, customer cs
						where cs.custid = od.custid;
						
						==> from 절 (인라인 뷰)
						==> 고객이름별로 평균 주문금액을 출력
						
						
					3) select sum(saleprice) total
						from orders od
						where exists (select * 
										from customer cs
										where custid <= 3 and cs.custid = od.custid);
	
						==> where 절 (중첩쿼리)
						==> exists 연산자를 이용하여 고객번호가 3번 이하인 고객들의 총 주문금액을 출력
	
-------------------------------------------------------------------------------------------------------------

* 뷰(View)
	- 하나 이상의 테이블을 합하여 만든 가상의 테이블
	- 실제로 존재하지 않는 가상의 테이블
	- 자주 사용하는 복잡한 sql을 미리 뷰를 만들어 두어 편리하게 사용할 수 있다.
	- 또, 사용자별로 접근할 수 있는 컬럼들만 추려서 뷰를 만들어 두면 보안유지상 중요한 정보를 보호할 수 있다.
	
	<기본문법>
	create view 뷰이름 [(열이름 [,...n])]
	as select문
	
	
	
		연습) '축구'관련 도서를 검색
			select * from book where bookname like '%축구%';
	
		
		연습) '축구' 관련 도서를 검색하는 뷰를 생성
			create view vw_book
			as select * from book where bookname like '%축구%';
	
		
		연습) 뷰를 통하여 '축구' 관련 도서를 검색
			select * from vw_book;
	
			BOOKID BOOKNAME          PUBLISHER          PRICE
			------ ----------------- --------------- --------
			     1 축구의 역사          굿스포츠              7,000
			     2 축구아는 여자         나무수              13,000
			     3 축구의 이해          대한출판사            22,000
				
	
		연습) 20번 부서에 근무하는 직원들의 사원번호, 사원명, 부서번호, 전화, 주소를 검색하는 뷰를 생성하고 조회해보기.
			create view vw_emp_20
			as select eno, ename, dno, phone, addr from emp where dno = 20;
	
			select * from vw_emp_20;
	
			
		
		연습) 뷰를 통해 추가가 가능한지 vw_emp_200을 통해 insert를 수행해 봅니다.
		
			insert into vw_emp_20 values(2000, '윤석열', 20, '0000', '서울');
			==> 뷰를 통해 레코드를 추가할 수 있다.
			==> 실제로 레코드는 뷰를 만들 때 사용한 부모테이블인 emp 테이블에 추가되었다.
			==> 그렇기 때문에 뷰 생성시에 사용한 컬럼 이외의 컬럼들은 null을 허용하거나 default 값이 설정되어 있어야 view를 통해 추가할 수 있다!
		
			추가가 가능하다면 실제 데이터에 어디에 추가가 될까요?
			
			추가가 되려면 만족해야하는 조건은 무엇일까요?
		
		
		
		연습) 뷰를 통해 수정할 수 있는지 실험해보자.
		
			update vw_emp_20 set ename = '이재명' where ename = '윤석열';
			==> 뷰를 통해 데이터를 수정할 수 있다.
			==> 실제로 테이블 생성 시에 사용한 모테이블인 emp에 수정이 된다.
	
	
		연습) 뷰를 생성할 때 사용한 조건식에 맞지 않는 값으로 수정이 가능한지 실험해보자.
		
			update vw_emp_20 set dno = 30 where ename= '이재명'; //원래의 vw_emp_20 테이블 조건은 dno=20 이어야 함.
			==> 뷰 생성시에 설정된 조건과 맞지 않는 값으로 수정 가능!
			==> 실제로 모테이블에서 수정이 되었으며 조건을 만족하지 않기 때문에 '이재명'의 데이터는 뷰에 나타나지 않는다.
	
	
	
		연습) 뷰를 통해 레코드를 삭제할 수 있는지 실험해보자
			
			update emp set dno = 20 where ename = '이재명';
			delete vw_emp_20 where eno = 2000;
			==> 뷰를 통해 레코드를 삭제할 수 있다.
			==> 실제로 뷰를 생성할 때 사용한 모테이블에서 삭제된다.
	
		
		연습) 뷰를 통해 뷰 생성시에 사용한 조건에 맞지 않는 레코드를 추가할 수 있는지 실험
		
			insert into vw_emp_20 values(2000, '윤석열', 30, '1111', '서울');
			==> 뷰 생성 시에 조건에 맞지 않는 레코드를 추가할 수 있다. 
			==> 실제로는 모테이블에 추가되고 뷰에는 조건식에 맞지 않기 때문에 나타나지 않는다.
	
	
----------------------------------------------------------------------------------------------------------------------

* 뷰 삭제
	drop view 뷰이름;



----------------------------------------------------------------------------------------------------------------------
* with check option
	- 뷰 생성 시에 사용한 조건식에 맞는 레코드만 추가, 수정하도록 하기 위한 옵션
	
	
	<기본문법>
	create view 뷰이름 as select ~~  조건식 with check option;
		
	create view vw_emp_20 as 
	select eno, ename, dno, phone, addr
	from emp
	where dno = 20
	with check option;
	
	<추가>
	insert into vw_emp_20 values(2001, '유관순', 20, '1111', '서울');
	
	insert into vw_emp_20 values(2002, '이재명', 30, '1111', '서울');
	1행에 오류:
	ORA-01402: 뷰의 WITH CHECK OPTION의 조건에 위배 됩니다
	==> 뷰 생성 시에 with check option을 주었기 때문에 조건에 맞지 않는 레코드를 추가할 수 없다.
	
	
	<수정>
	update vw_emp_20 set dno = 30 where eno = 2001;
	1행에 오류:
	ORA-01402: 뷰의 WITH CHECK OPTION의 조건에 위배 됩니다
	==> 뷰 생성 시에 with check option을 주었기 때문에 조건에 맞지 않는 레코드를 수정할 수 없다.
	
------------------------------------------------------------------------------------------------------

* 조회만 가능한 뷰의 생성
	with read only
	
	<기본문법>
	create view 뷰이름 as select with read only;
	
	create view vw_emp_20 as 
	select eno, ename, addr, dno
	from emp
	where dno = 20 with read only;
	
	
	insert into vw_emp_20 values(3000, '이순신', '서울', '7777');
	1행에 오류:
	ORA-42399: 읽기 전용 뷰에서는 DML 작업을 수행할 수 없습니다.	
	
	
-------------------------------------------------------------------------------------------------------
	
	
	insert into orders values(16, 4, 1, 10000, sysdate, '축구의 역사');
	insert into orders values(17, 1, 1, 10000, sysdate, null);
	insert into orders values(18, 2, 1, 10000, sysdate, null);
	insert into orders values(19, 3, 1, 10000, sysdate, null);
	insert into orders values(20, 4, 1, 10000, sysdate, null);
	
	insert into orders values(21, 1, 5, 20000, sysdate, null);
	insert into orders values(22, 2, 5, 20000, sysdate, null);
	insert into orders values(23, 3, 5, 20000, sysdate, null);
	insert into orders values(24, 4, 5, 20000, sysdate, null);
	insert into orders values(25, 5, 5, 20000, sysdate, null);
	
	
	insert into orders values(26, 1, 3, 15000, sysdate, null);
	insert into orders values(27, 3, 3, 15000, sysdate, null);
	
	정렬하고, 행번호 붙이고, 3개만 뽑아오기
	
	
	

-------------------------------------------------------------------------------------------

팀별연습문제) 오늘날짜의 가장 많이 판매된 세권의 도서의 도서별 총판매수를
	 출력하는 view를 만들고 이것의 결과를 출력하는 웹 문서를 작성 해 봅니다.
	(오늘 날짜의 판매내역을 추가하여 테스트합니다.) 
	
	- 오늘 날짜에 판매된 도서번호 별로 판매수를 출력
		select bookid, count(orderid)
		from orders
		where orderdate = sysdate
		group by bookid;
		==> 선택된 레코드가 없습니다.
		==> sysdate은 년, 월, 일 뿐 아니라 시, 분, 초에 대한 정보도 함께 갖고 있다.
			오늘 날짜이기는 하지만 도서를 추가할 때에 시, 분, 초와 현재 조회할 때의 시, 분, 초가 달라서
			레코드가 조회되지 않는다.
	
		==> 어떻게 해야 할까요?
			select bookid, count(orderid)
			from orders
			where to_char(orderdate, 'yyyy/mm/dd') = to_char(sysdate, 'yyyy/mm/dd')
			group by bookid;
			
			BOOKID COUNT(ORDERID)
			------ --------------
			     1              3
			     5              5
			     3              2
			     7              1
			     
			==> 이것을 판매수량 순으로 내림차순 정렬합니다.
			
			
			select bookid, count(orderid)
			from orders
			where to_char(orderdate, 'yyyy/mm/dd') = to_char(sysdate, 'yyyy/mm/dd')
			group by bookid
			order by count(orderid) desc;
			
			
			BOOKID COUNT(ORDERID)
			------ --------------
			     5              5
			     1              3
			     3              2
			     7              1
			     
			==> 위의 sql을 from절의 서브쿼리로 하여 행번호가 3이하인 것을 추출
			
				select * from (select bookid, count(orderid)
									from orders
									where to_char(orderdate, 'yyyy/mm/dd') = to_char(sysdate, 'yyyy/mm/dd')
									group by bookid
									order by count(orderid) desc) 
				where rownum <= 3;
		
			BOOKID COUNT(ORDERID)
			------ --------------
			     5              5
			     1              3
			     3              2
	
			==> 위의 결과에 스칼라 서브쿼리를 이용하여 도서명을 같이 출력
			
				select bookid, (select bookname from book b 
									where b.bookid = a.bookid ) bookname ,cnt 
				from (select bookid, count(orderid) cnt
						from orders
						where to_char(orderdate, 'yyyy/mm/dd') = to_char(sysdate, 'yyyy/mm/dd')
						group by bookid
						order by count(orderid) desc) a
				where rownum <= 3;
				
				
				
				BOOKID BOOKNAME                 CNT
				------ ----------------- ----------
				     5 피겨 교본                    5
				     1 축구의 역사                   3
				     3 축구의 이해                   2
				     
				     
			==> 위의 결과를 조회하는 뷰를 생성
			
				create view top4 as
				select bookid, (select bookname from book b 
									where b.bookid = a.bookid ) bookname ,cnt 
				from (select bookid, count(orderid) cnt
						from orders
						where to_char(orderdate, 'yyyy/mm/dd') = to_char(sysdate, 'yyyy/mm/dd')
						group by bookid
						order by count(orderid) desc) a
				where rownum <= 3;
				
	
	insert into orders values(11,1, 1, 10000, sysdate);
	insert into orders values(12,2, 1, 10000, sysdate);
	insert into orders values(13,3, 1, 10000, sysdate);
	insert into orders values(14,4, 1, 10000, sysdate);

	
	insert into orders values(15,1, 5, 20000, sysdate);
	insert into orders values(16,2, 5, 20000, sysdate);
	insert into orders values(17,3, 5, 20000, sysdate);
	insert into orders values(18,4, 5, 20000, sysdate);
	insert into orders values(19,5, 5, 20000, sysdate);
	
	
	insert into orders values(20,1, 3, 15000, sysdate);
	insert into orders values(21,3, 3, 15000, sysdate);
	 
	insert into orders values(22,5, 7, 30000, sysdate);
	 
	 
	===> 정렬하고, 행번호를 붙이고, 3개만 뽑아오기
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	 
