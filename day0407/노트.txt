* 추상클래스와 추상메소드
	- 추상메소드는 미래에 후손클래스들이 반드시 가져야 할 메소드이지만 부모클래스를 만드는 시점에서 구체화 할 수 없는 경우 메소드 몸체를 정의하지 않고, 
	  메소드 선언문만 명시한다. 이것을 "추상메소드"라 하고 메소드 이름 왼쪽에 abstract 키워드를 써준다.
	- 이와 같이 추상메소드를 하나라도 포함하고 있는 클래스를 "추상클래스"라고 하고, 클래스 이름 왼쪽에 abstract 키워드를 써준다.
	- 추상클래스는 추상메소드 뿐 아니라 body가 구체화된 메소드를 포함할 수 있다.
	- 또, 추상클래스는 body를 구체화하지 않는 메소드를 포함하고 있기 때문에 추상클래스의 객체는 생성할 수 없다.
	- 반드시 그 추상클래스를 상속받아 추상메소드를 구현한 클래스의 객체를 생성해야 한다.
	
	
* 익명클래스
	- 이름없는 클래스를 말한다.
	- 추상클래스를 상속받은 클래스를 정의하는데 따로 이름을 정해주지 않고 바로 추상메소드를 오버라이딩한 클래스를 만들면서 객체를 생성할 때 사용한다.
	
	

* 객체지향 프로그래밍 중의 하나인 c++에서는 클래스의 다중상속이 가능하다.
	(c++)
	
	class A {
		public void pro() {
		}
	}
	
	class B {
		public void pro() {
		}
	}
	
	class C : A,B //다중 상속이 가능하다.
 	{
	
	}
	
	C ob = new A();
	ob.pro(); //부모 A의 pro를 호출해야 할지, B의 pro를 호출해야할지.. 오류가 발생하게 된다.
	
	- 이러한 문제점때문에 java에는 클래스의 다중상속을 금지시키고 있다.
	
	
	
* 인터페이스
	- 다중상속의 효과를 기대할 목적으로 "인터페이스"를 사용한다. (클래스의 다중상속은 되지 않고, 인터페이스를 이용한다.)
	
	class 클래스명 {
	
	}
	
	interface 인터페이스명 {
	
	}
	
	- 인터페이스는 "완전추상"의 개념이며, 인터페이스의 구성요소는 상수와 추상메소드 만으로 구성된다. (일반변수x)
	- 인터페이스 안에 변수이름 앞에 final을 붙이지 않아도 자동 final이다.
	- 인터페이스 안에 메소드 이름 앞에 abstract을 붙이지 않아도 자동 abstract이다.
	
	
	
* 문자열 처리
	- 자바에서는 문자열 처리를 위하여 String, StringBuffer, StringBuilder 의 클래스를 사용한다.
	
	* String
		- String의 특성은 변하지 않는 문자열이다.
	
	* StringBuffer와 StringBuilder는 변하는 문자열이다. (둘이 동작하는 방법은 같다.)
	
	
	
* java.lang
	- 자바가 제공하는 클래스를 사용하기 위해서는 import를 해야한다.
	- 그러나 java.lang 패키지의 모든 클래스들은 자동으로 import 되기 때문에 사용자가 따로 import를 하지 않아도 된다.
	
	
	
* 기본자료형 ==> String
	String.valueOf()
	기본자료형 + "";
	
	

* String ==> 기본자료형
	Wrapper 클래스들을 이용
	- 각 기본자료형에 따른 클래스들을 말한다.
	
	<Wrapper 클래스>

	- boolean		Boolean
	- byte			Byte
	- char			Character
	- short			Short
	- int 			Integer
	- long 			Long
	- float 		Float
	- double 		Double
	
	
	

* 예외처리
	- 프로그램 실행 중에 사용자의 부주의 등으로 인하여 예기치 않는 상황이 발생하는 것을 예외 라고 하며, 이것을 처리하는 것을 "예외처리"라고 한다.
	- 자바에서는 대부분의 발생할 수 있는 예외에 대하여 이미 클래스로 만들어져 있다.
	- 그 상황이 되면 자동으로 예외객체가 생성된다.
	
	int []a = {10, 20, 30};
	a[4] = 5; //배열의 범위를 넘었을 때
	
	new ArrayIndexOutOfBoundException() ==> 자동으로 객체 생성
	
	==> 예외가 발생할만한 코드를 그대로 두게되면 사용자로부터 신뢰를 잃게된다. 
	==> 그렇기 때문에 우리는 예외처리를 해줘야 한다.
	

* 예외처리 하는 방법

	try {
		예외가 발생할 만한 문장(들)
	} catch(예외자료형 변수명) { //여기서 캐치
		처리할 문장
	}
	
	
	
	
	
	
	
	
	
	
	
	